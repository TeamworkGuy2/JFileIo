package twg2.io.exec;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.logging.Level;

import twg2.logging.LogService;
import twg2.logging.Logger;
import twg2.logging.LoggerImpl;

public class ReadInputStream implements Runnable {
	private Logger log;
	private InputStream in;
	private OutputStream out;
	private Object waitObj = new Object();
	private volatile boolean keepReading = true;


	/**
	 * @param inputStream the input stream to read from
	 * @param outputStream the output stream to write the input
	 * stream's contents to, or null to discard the contents.
	 */
	public ReadInputStream(InputStream inputStream, OutputStream outputStream, LogService log) {
		this.log = log != null ? new LoggerImpl(log, this.getClass()) : null;
		this.in = inputStream;
		this.out = outputStream;
	}


	/** Resets this input stream reader
	 * @param inputStream
	 * @param outputStream
	 */
	public void resetWithNewStreams(InputStream inputStream, OutputStream outputStream) {
		stop();
		this.keepReading = true;
		this.in = inputStream;
		this.out = outputStream;
		synchronized(waitObj) {
			waitObj.notify();
		}
	}


	public void stop() {
		keepReading = false;
		if(this.in != null) {
			try {
				this.in.close();
				this.in = null;
			} catch (IOException e) {
				this.in = null;
				e.printStackTrace();
			}
		}
		synchronized(waitObj) {
			waitObj.notify();
		}
	}


	@Override
	public void run() {
		int size = 2048;
		byte[] buf = new byte[size];
		int waitCount = 0;
		final int maxWaitCount = 20;
		final int waitIntervalMs = 1000;
		boolean throwWaitCountError = false;

		synchronized(waitObj) {
			while(keepReading) {
				//int readCount = 0;
				int readLength = 0;
				boolean waitingForInNotNull = in == null;
				waitCount = 0;

				while(keepReading && waitCount < maxWaitCount) {
					// read from the input stream while keepReading is true or until an error occurs
					// (which is sometimes purposely generated by closing the stream)
					try {
						while(keepReading && in != null && (readLength = in.read(buf, 0, size)) != -1) {
							//readCount += readLength;
							if(out != null) {
								out.write(buf, 0, readLength);
							}
						}
					} catch(IOException ioe) {
						in = null;
						if(Logger.wouldLog(log, Level.SEVERE)) {
							log.log(Level.SEVERE, "Error reading input stream or writing output stream: ", ioe);
						}
					}

					// once the input stream read ends, wait for the wait object to be notified
					// the loop checking for the inputStream to become not-null in case of spurious wait/notify calls
					try {
						if(Logger.wouldLog(log, Level.FINER)) {
							log.log(Level.FINER, "thread '" + Thread.currentThread().getName() + (waitingForInNotNull ? "' start waiting for input stream" : "' start waiting") + ", (byteCount=" + readLength + ", inputStream=" + in + ")");
						}

						waitObj.wait(waitIntervalMs);

						if(Logger.wouldLog(log, Level.FINER)) {
							log.log(Level.FINER, "thread '" + Thread.currentThread().getName() + (waitingForInNotNull ? "' done waiting for input stream" : "' done waiting") + ", (byteCount=" + readLength + ", inputStream=" + in + ")");
						}
					} catch (InterruptedException e) {
						e.printStackTrace();
						waitCount++;
					}
					// if the input stream was null, but isn't any more, exit the wait loop
					if(waitingForInNotNull && in == null) {
						break;
					}
				}
				// if the loop ended with too many wait error loops
				if(waitCount >= maxWaitCount) {
					throwWaitCountError = true;
					break;
				}
			}
		}

		if(throwWaitCountError) {
			throw new IllegalStateException("could not finish reading input stream, waited for more input " + waitCount + " times");
		}

	}

}